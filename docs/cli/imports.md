# Imports Command – Comprehensive Reference

The `raiden imports` command fetches Supabase resources (tables, roles, RPC functions, storage buckets, and types) and generates corresponding Go source files in the local project. This document covers the full architecture, execution flow, data model, flags, error handling, and key implementation details.

---

## Table of Contents

1. [Overview](#overview)
2. [Usage & Flags](#usage--flags)
3. [Execution Flow](#execution-flow)
4. [Phase-by-Phase Breakdown](#phase-by-phase-breakdown)
5. [Architecture Diagrams](#architecture-diagrams)
6. [Key Data Structures](#key-data-structures)
7. [Resource Loading (BFF vs Service Mode)](#resource-loading-bff-vs-service-mode)
8. [State Management](#state-management)
9. [Comparison & Diff Logic](#comparison--diff-logic)
10. [Code Generation](#code-generation)
11. [File Map](#file-map)
12. [Error Handling](#error-handling)
13. [Troubleshooting](#troubleshooting)

---

## Overview

`raiden imports` synchronises the local project with the remote Supabase database by:

1. Fetching remote resources (tables, roles, functions, storages, types, policies, indexes).
2. Loading the local state (`.raiden/` binary state files).
3. Comparing remote vs local to detect drift.
4. Generating/updating Go source files under `internal/` (models, roles, rpc, storages, types).
5. Persisting the updated state.

The command uses a **two-stage build** approach: the Raiden CLI first code-generates a temporary `cmd/import/main.go` binary that embeds the user's registered models and bootstrap code, then compiles and executes that binary to perform the actual import.

---

## Usage & Flags

```bash
raiden imports [flags]
```

### Resource Selection Flags

| Flag | Short | Description |
|------|-------|-------------|
| `--models-only` | `-m` | Import tables/models only |
| `--rpc-only` | | Import RPC functions only |
| `--roles-only` | `-r` | Import roles only |
| `--storages-only` | | Import storage buckets only |
| `--policy-only` | | Import policies only |
| `--schema` | `-s` | Comma-separated list of schemas to include (default: `public`) |

When **no** resource flag is set, all resources are imported.

### Behaviour Flags

| Flag | Description |
|------|-------------|
| `--force` | Skip diff checks and overwrite local state unconditionally |
| `--dry-run` | Simulate the import without writing files; reports what would change |
| `--generate-controller` | Generate REST controller stubs for imported tables (BFF mode only) |

### Debug Flags

| Flag | Description |
|------|-------------|
| `--debug` | Enable debug-level logging |
| `--trace` | Enable trace-level logging (most verbose) |

### Examples

```bash
# Import everything from public schema
raiden imports

# Import only models from auth and public schemas
raiden imports --models-only --schema auth,public

# Dry run to preview changes
raiden imports --dry-run

# Force overwrite without diff checks
raiden imports --force

# Import models and auto-generate controllers
raiden imports --models-only --generate-controller

# Import with debug logging
raiden imports --debug
```

---

## Execution Flow

The import process spans three layers: the CLI command, the compiled import binary, and the core import logic.

### High-Level Flow

```
User runs: raiden imports --schema public,auth
    │
    ▼
┌──────────────────────────────────────────────────────┐
│ Layer 1: CLI Command (cmd/raiden/commands/import.go)  │
│                                                       │
│  1. PreRun: verify configs/app.yaml exists            │
│  2. Version check (auto-update if needed)             │
│  3. Load config: raiden.LoadConfig()                  │
│  4. generate.Run() — refresh internal/bootstrap       │
│  5. imports.Run() — build & exec import binary        │
└──────────────────────┬───────────────────────────────┘
                       │
                       ▼
┌──────────────────────────────────────────────────────┐
│ Layer 2: Build & Exec (pkg/cli/imports/command.go)    │
│                                                       │
│  1. Build: go build -o build/import cmd/import/main.go│
│  2. Assemble args from flags                          │
│  3. Exec: build/import --schema public,auth           │
└──────────────────────┬───────────────────────────────┘
                       │
                       ▼
┌──────────────────────────────────────────────────────┐
│ Layer 3: Import Binary (cmd/import/main.go)           │
│   (code-generated by pkg/generator/import.go)         │
│                                                       │
│  1. Load config                                       │
│  2. bootstrap.RegisterModels/Types/Rpc/Roles/Storages │
│  3. generate.Run() — pre-generate pass                │
│  4. resource.Import(flags, config) ← CORE             │
│  5. generate.Run() — post-generate (bootstrap regen)  │
└──────────────────────┬───────────────────────────────┘
                       │
                       ▼
┌──────────────────────────────────────────────────────┐
│ Layer 4: Core Import (pkg/resource/import.go)         │
│                                                       │
│  importJob.run() executes 9 phases:                   │
│                                                       │
│  Phase 1: loadNativeRoles                             │
│  Phase 2: loadRemoteResource                          │
│  Phase 3: prepareRemoteResource                       │
│  Phase 4: loadLocalState                              │
│  Phase 5: extractAppResources                         │
│  Phase 6: collectValidationTags                       │
│  Phase 7: performComparisons                          │
│  Phase 8: computeReport                               │
│  Phase 9: handleOutput                                │
└──────────────────────────────────────────────────────┘
```

---

## Phase-by-Phase Breakdown

### Phase 1: Load Native Roles

**Function:** `importJob.loadNativeRoles()`  
**Source:** `pkg/resource/import.go`  

Loads the built-in PostgreSQL/Supabase roles (e.g., `postgres`, `supabase_admin`, `pg_*`) into a map. These are used later to distinguish user-defined roles from system roles.

**Data source:** `pkg/postgres/roles.NativeRoles` — a hard-coded list of known native roles.

---

### Phase 2: Load Remote Resource

**Function:** `importJob.loadRemoteResource()`  
**Source:** `pkg/resource/load.go :: Load()`  

Fetches all resources from the Supabase database **concurrently** using goroutines. The resources loaded depend on the flags and the server mode (BFF vs Service).

Resources fetched:
- Tables (with columns, primary keys, relationships)
- Roles and role memberships
- Functions (RPC)
- Storage buckets
- Indexes
- Relationship actions (ON DELETE, ON UPDATE)
- Policies (ACL)
- Types (custom PostgreSQL types)

After loading, post-processing attaches:
- Indexes and relation actions to their respective tables via `tables.AttachIndexAndAction()`
- Inherited roles via `roles.AttachInherithRole()`

---

### Phase 3: Prepare Remote Resource

**Function:** `importJob.prepareRemoteResource()`  
**Source:** `pkg/resource/import.go`  

Filters the fetched resources to only include what the user requested:

1. **Schema filter:** Tables and functions are filtered by `--schema` (defaults to `public`).
2. **Allowed tables filter** (BFF mode only): When `config.AllowedTables` is set, further restricts which tables are included. Relationships referencing excluded tables are also removed.
3. **Native role removal:** System roles are removed from the role list, keeping only user-defined roles.
4. **Relation validation:** Logs warnings for relationships referencing tables outside the import set.

---

### Phase 4: Load Local State

**Function:** `importJob.loadLocalState()`  
**Source:** `pkg/state/state.go :: Load()`  

Reads the local state from `.raiden/` directory. The state is stored as binary GOB files and tracks what was previously imported:
- Tables with their columns, relations, and policies
- Roles
- RPC functions
- Storage buckets
- Types

If no state exists (first import), this returns an empty state.

---

### Phase 5: Extract App Resources

**Function:** `importJob.extractAppResources()`  
**Source:** `pkg/resource/common.go :: extractAppResource()`  

Compares the local state against the currently registered Go resources (from `bootstrap.Register*()` calls) and categorises each resource as either **New** or **Existing**.

The output for each resource type contains:
- `New` — resources in local state but not yet registered in Go code
- `Existing` — resources that exist in both state and Go code

This is used later for comparison and reporting.

---

### Phase 6: Collect Validation Tags

**Function:** `importJob.collectValidationTags()`  
**Source:** `pkg/resource/import.go`  

Preserves existing model validation tags (e.g., `validate:"required"`) so they aren't lost during code regeneration. Tags are collected from both new and existing table extractions and stored in `mapModelValidationTags`.

Only runs when importing models (`--models-only` or all resources).

---

### Phase 7: Perform Comparisons

**Function:** `importJob.performComparisons()`  
**Source:** `pkg/resource/import.go`  

**Skipped entirely when `--force` is used.**

Runs diff checks between remote (Supabase) and local (existing Go code) resources:

| Comparison | Package | What it checks |
|-----------|---------|---------------|
| `types.Compare()` | `pkg/resource/types` | Custom type definitions |
| `tables.Compare()` | `pkg/resource/tables` | Table structure, columns, constraints |
| `roles.Compare()` | `pkg/resource/roles` | Role configuration |
| `rpc.Compare()` | `pkg/resource/rpc` | Function signatures, parameters |
| `storages.Compare()` | `pkg/resource/storages` | Bucket configuration |

Each comparison:
- Returns an **error** if drift is detected and conflicts exist.
- In `--dry-run` mode, errors are collected (not returned) for reporting.
- Only runs for the resource types being imported and when existing resources are present.

---

### Phase 8: Compute Report

**Function:** `importJob.computeReport()`  
**Source:** `pkg/resource/import.go`  

Counts how many **new** resources would be added for each type by calling `GetNewCountData()` from each resource package. The report contains counts for:

```go
type ImportReport struct {
    Table    int
    Role     int
    Rpc      int
    Storage  int
    Types    int
    Policies int
}
```

---

### Phase 9: Handle Output

**Function:** `importJob.handleOutput()`  
**Source:** `pkg/resource/import.go`  

Decides what to do based on flags:

| Condition | Action |
|-----------|--------|
| `--dry-run` with errors | Print collected errors, skip report |
| `--dry-run` without errors | Print report showing what would be imported |
| `--update-state-only` | Update `.raiden/` state without generating code |
| Normal (no flags) | Run `generateImportResource()` → generate Go files + update state |

---

## Architecture Diagrams

### Sequence Diagram

See [imports-sequence.md](./imports-sequence.md) for the full Mermaid sequence diagram.

### Structural Diagram

See [imports-structure.md](./imports-structure.md) for the class-style package relationship diagram.

### Dependency Injection

The `importJob` struct uses a `importDeps` struct for dependency injection, making each phase testable:

```
importDeps {
    loadNativeRoles  → pkg/postgres/roles.NativeRoles
    loadRemote       → pkg/resource.Load()
    loadState        → pkg/state.Load()
    extractApp       → extractAppResource()
    compareTypes     → pkg/resource/types.Compare()
    compareTables    → pkg/resource/tables.Compare()
    compareRoles     → pkg/resource/roles.Compare()
    compareRpc       → pkg/resource/rpc.Compare()
    compareStorages  → pkg/resource/storages.Compare()
    updateStateOnly  → updateStateOnly()
    generate         → generateImportResource()
    printReport      → PrintImportReport()
}
```

---

## Key Data Structures

### Resource (remote data container)

```go
// pkg/resource/load.go
type Resource struct {
    Tables          []objects.Table
    Policies        objects.Policies
    Roles           []objects.Role
    RoleMemberships []objects.RoleMembership
    Functions       []objects.Function
    Storages        []objects.Bucket
    Indexes         []objects.Index
    RelationActions []objects.TablesRelationshipAction
    Types           []objects.Type
}
```

### Flags (import options)

```go
// pkg/resource/common.go
type Flags struct {
    ProjectPath        string
    RpcOnly            bool
    RolesOnly          bool
    ModelsOnly         bool
    StoragesOnly       bool
    AllowedSchema      string
    DebugMode          bool
    TraceMode          bool
    Generate           generate.Flags
    GenerateController bool
    ForceImport        bool
    UpdateStateOnly    bool
    DryRun             bool
}
```

`Flags.All()` returns `true` when no resource-specific flag is set (imports everything).

### State (local persistence)

```go
// pkg/state/state.go
type State struct {
    Tables  []TableState
    Roles   []RoleState
    Rpc     []RpcState
    Storage []StorageState
    Types   []TypeState
}

type TableState struct {
    Table       objects.Table
    Relation    []Relation
    ModelPath   string
    ModelStruct string
    LastUpdate  time.Time
    Policies    []objects.Policy
}
```

### importJob (workflow state)

```go
// pkg/resource/import.go
type importJob struct {
    flags                  *Flags
    config                 *raiden.Config
    deps                   importDeps
    mapNativeRole          map[string]raiden.Role
    resource               *Resource
    localState             *state.State
    importState            state.LocalState
    appTables              state.ExtractTableResult
    appRoles               state.ExtractRoleResult
    appRpcFunctions        state.ExtractRpcResult
    appStorage             state.ExtractStorageResult
    appTypes               state.ExtractTypeResult
    nativeStateRoles       []state.RoleState
    dryRunErrors           []string
    mapModelValidationTags map[string]state.ModelValidationTag
    report                 ImportReport
    reportComputed         bool
    reportPrinted          bool
    skipReport             bool
}
```

---

## Resource Loading (BFF vs Service Mode)

The `Load()` function behaves differently based on `config.Mode`:

### BFF Mode (`raiden.BffMode`)

Uses the **Supabase REST API** (`pkg/supabase`) to fetch resources:

```
Supabase API ──► supabase.GetTables()
               ► supabase.GetFunctions()
               ► supabase.GetRoles()
               ► supabase.GetBuckets()
               ► supabase.GetPolicies()
               ► supabase.GetTypes()
               ► supabase.GetIndexes()
               ► supabase.GetRoleMemberships()
               ► supabase.GetTableRelationshipActions()
```

**Selective loading:** Only loads resource types matching the flags. For example, `--rpc-only` skips loading tables, roles, and storages (but loads types and tables for function parameter resolution).

### Service Mode

Uses **PgMeta** (`pkg/connector/pgmeta`) for direct PostgreSQL metadata access:

```
PgMeta ──► pgmeta.GetTables()
          ► pgmeta.GetFunctions()
          ► pgmeta.GetIndexes()
          ► pgmeta.GetTableRelationshipActions()
          ► pgmeta.GetTypes()
```

Roles are still loaded via the Supabase API. Storage buckets are **not loaded** in Service mode.

### Concurrency

All resource loads run concurrently as goroutines, sending results through a shared channel. The `Load()` function collects results using a type switch:

```go
for result := range loadChan {
    switch rs := result.(type) {
    case []objects.Table:    resource.Tables = rs
    case []objects.Role:     resource.Roles = rs
    case []objects.Function: resource.Functions = rs
    case error:              return nil, rs
    // ...
    }
}
```

---

## State Management

### State Location

State files are stored in the `.raiden/` directory at the project root, using Go's GOB binary encoding.

### State Lifecycle

```
First Import:
  No state exists → all resources treated as "new"
  → generate files → persist state

Subsequent Imports:
  Load state → extract registered resources
  → classify as New/Existing
  → compare Existing against remote
  → generate only what changed → persist updated state
```

### LocalState Operations

The `LocalState` struct provides thread-safe operations:

- `AddTable(TableState)` — adds or updates a table in state
- `AddRole(RoleState)` — adds or updates a role in state
- `AddRpc(RpcState)` — adds or updates an RPC function in state
- `AddStorage(StorageState)` — adds or updates a storage bucket in state
- `AddType(TypeState)` — adds or updates a custom type in state
- `Persist()` — writes state to disk

### State Update During Generation

During code generation, each generated file emits a message through `stateChan`. The `UpdateLocalStateFromImport()` goroutine listens on this channel and updates the `LocalState` in real-time. When the channel closes (generation complete), it calls `Persist()`.

---

## Comparison & Diff Logic

Each resource type has its own comparison package under `pkg/resource/`:

| Package | Compare Function | What It Checks |
|---------|-----------------|----------------|
| `pkg/resource/types` | `Compare(remote, existing)` | Type name, attributes, schema |
| `pkg/resource/tables` | `Compare(mode, remote, existing)` | Columns, types, constraints, defaults, nullability |
| `pkg/resource/roles` | `Compare(remote, existing)` | Role name, permissions, inheritance |
| `pkg/resource/rpc` | `Compare(remote, existing)` | Function name, parameters, return type, schema |
| `pkg/resource/storages` | `Compare(remote, existing)` | Bucket name, public flag, size limits |

### Comparison Modes

`tables.Compare()` accepts a mode parameter:
- `CompareModeImport` — used during imports (remote is source of truth)
- Other modes may exist for apply operations

### Force Import

When `--force` is set, **all comparisons are skipped**. The remote state overwrites local state unconditionally. Use with caution.

### Dry Run

When `--dry-run` is set, comparison errors are **collected** instead of returned. The command prints either:
- A success report with counts of new resources
- An error summary if drift/conflicts exist

---

## Code Generation

### Generated File Structure

```
project/
├── internal/
│   ├── bootstrap/       # Auto-generated registration code
│   │   ├── models.go
│   │   ├── roles.go
│   │   ├── rpc.go
│   │   ├── storages.go
│   │   └── types.go
│   ├── models/          # Table model structs
│   │   ├── users.go
│   │   └── orders.go
│   ├── roles/           # Role definitions
│   │   └── custom_role.go
│   ├── rpc/             # RPC function wrappers
│   │   └── get_stats.go
│   ├── storages/        # Storage bucket definitions
│   │   └── avatars.go
│   └── types/           # Custom PostgreSQL types
│       └── status_enum.go
├── cmd/
│   └── import/
│       └── main.go      # Code-generated import binary
└── .raiden/             # Binary state files (GOB encoded)
```

### Generation Pipeline

The `generateImportResource()` function runs all generators concurrently in a single goroutine:

1. **Types** → `generator.GenerateTypes()` — custom PostgreSQL type enums/structs
2. **Models** → `generator.GenerateModels()` — table struct definitions with column tags
3. **Controllers** → `generator.GenerateRestControllers()` — REST controller stubs (optional, BFF only)
4. **Roles** → `generator.GenerateRoles()` — role struct definitions
5. **RPC** → `generator.GenerateRpc()` — function parameter/return type structs
6. **Storages** → `generator.GenerateStorages()` — bucket definitions with policies

### Capture Function Pattern

Each generator wraps the standard `generator.Generate()` with `ImportDecorateFunc()`, which:
1. Generates the file content normally
2. Finds the matching resource item
3. Sends the item + output path to `stateChan` for state tracking

---

## File Map

| File | Role |
|------|------|
| `cmd/raiden/commands/import.go` | CLI command definition, flag binding, orchestration |
| `pkg/cli/imports/command.go` | Builds and executes the import binary subprocess |
| `pkg/generator/import.go` | Code-generates `cmd/import/main.go` template |
| `pkg/resource/import.go` | **Core logic** — `importJob` struct, all 9 phases, code generation |
| `pkg/resource/load.go` | `Resource` struct, `Load()`, concurrent resource fetching |
| `pkg/resource/common.go` | `Flags` struct, filter functions, `extractAppResource()` |
| `pkg/state/state.go` | `State` / `LocalState` structs, GOB persistence |
| `pkg/state/table.go` | Table state extraction and comparison |
| `pkg/state/role.go` | Role state extraction |
| `pkg/state/rpc.go` | RPC state extraction |
| `pkg/state/storage.go` | Storage state extraction |
| `pkg/state/type.go` | Type state extraction |
| `pkg/resource/tables/` | Table comparison, index/action attachment, model input building |
| `pkg/resource/roles/` | Role comparison, inheritance attachment |
| `pkg/resource/rpc/` | RPC function comparison |
| `pkg/resource/storages/` | Storage comparison, input building |
| `pkg/resource/types/` | Type comparison |
| `pkg/resource/policies/` | Policy ACL expression cleanup |

### Test Files

| File | Coverage |
|------|----------|
| `pkg/resource/import_test.go` | Integration tests for the full import flow |
| `pkg/resource/import_internal_test.go` | White-box tests for internal helpers |
| `pkg/generator/import_test.go` | Tests for import binary code generation |

---

## Error Handling

### Panic Recovery

The `runImport()` function includes a deferred panic recovery:

```go
defer func() {
    if r := recover(); r != nil {
        err = fmt.Errorf("import panic: %v", r)
    }
}()
```

### Error Propagation

- **Phase errors** propagate up immediately, aborting the import.
- **Comparison errors** are either returned (normal mode) or collected (dry-run mode).
- **Generation errors** are sent through `errChan` and returned on the first error.
- **State persistence errors** are returned via the `doneListen` channel.

### Common Error Scenarios

| Error | Cause | Resolution |
|-------|-------|------------|
| `missing config file` | `configs/app.yaml` not found | Run `raiden configure` |
| `error building binary` | Compilation of `cmd/import/main.go` failed | Check Go code syntax, run `go build ./...` |
| Comparison error | Remote schema differs from local state | Use `--force` to overwrite, or reconcile manually |
| Load error | Network/auth failure when fetching from Supabase | Check config credentials and connectivity |

---

## Troubleshooting

### Debug Logging

```bash
# See which tables/functions are included/excluded
raiden imports --debug

# See full filter details and schema matching
raiden imports --trace
```

### Preview Without Changes

```bash
raiden imports --dry-run
```

### Reset Local State

Delete the `.raiden/` directory to force a clean import:

```bash
rm -rf .raiden/
raiden imports
```

### Schema Filtering Issues

If tables are missing, verify the schema:

```bash
# Import from multiple schemas
raiden imports --schema public,auth,storage

# Debug to see what's being filtered
raiden imports --schema public,auth --debug
```

### Force Overwrite

When comparison errors block import (e.g., after manual DB changes):

```bash
raiden imports --force
```
