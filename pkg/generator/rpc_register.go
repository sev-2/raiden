package generator

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"path/filepath"
	"strings"

	"github.com/hashicorp/go-hclog"
	"github.com/sev-2/raiden/pkg/logger"
	"github.com/sev-2/raiden/pkg/utils"
)

var RpcRegisterLogger hclog.Logger = logger.HcLog().Named("generator.rpc_register")

// ----- Define type, variable and constant -----
type (
	GenerateRegisterRpcData struct {
		Imports []string
		Package string
		Rpc     []string
	}
)

const (
	RpcRegisterFilename = "rpc.go"
	RpcRegisterDir      = "internal/bootstrap"
	RpcRegisterTemplate = `// Code generated by raiden-cli; DO NOT EDIT.
package {{ .Package }}
{{if gt (len .Imports) 0 }}
import (
{{- range .Imports}}
	{{.}}
{{- end}}
)
{{end }}
func RegisterRpc() {
	resource.RegisterRpc(
		{{- range .Rpc}}
		&rpc.{{.}}{},
		{{- end}}
	)
}
`
)

func GenerateRpcRegister(basePath string, projectName string, generateFn GenerateFn) error {
	rpcRegisterDir := filepath.Join(basePath, RpcRegisterDir)
	RpcRegisterLogger.Trace("create bootstrap folder if not exist", "path", rpcRegisterDir)
	if exist := utils.IsFolderExists(rpcRegisterDir); !exist {
		if err := utils.CreateFolder(rpcRegisterDir); err != nil {
			return err
		}
	}

	rpcDir := filepath.Join(basePath, RpcDir)
	RpcRegisterLogger.Trace("create rpc folder if not exist", "path", rpcDir)
	if exist := utils.IsFolderExists(rpcDir); !exist {
		if err := utils.CreateFolder(rpcDir); err != nil {
			return err
		}
	}

	// scan all controller
	rpcList, err := WalkScanRpc(rpcDir)
	if err != nil {
		return err
	}

	input, err := createRegisterRpcInput(projectName, rpcRegisterDir, rpcList)
	if err != nil {
		return err
	}

	RpcRegisterLogger.Debug("generate rpc", "path", input.OutputPath)
	return generateFn(input, nil)
}

func createRegisterRpcInput(projectName string, rpcRegisterDir string, rpcList []string) (input GenerateInput, err error) {
	// set file path
	filePath := filepath.Join(rpcRegisterDir, RpcRegisterFilename)

	// set imports path
	imports := []string{
		fmt.Sprintf("%q", "github.com/sev-2/raiden/pkg/resource"),
	}

	if len(rpcList) > 0 {
		rpcImportPath := fmt.Sprintf("%s/internal/rpc", utils.ToGoModuleName(projectName))
		imports = append(imports, fmt.Sprintf("%q", rpcImportPath))
	}

	// set passed parameter
	data := GenerateRegisterRpcData{
		Package: "bootstrap",
		Imports: imports,
		Rpc:     rpcList,
	}

	input = GenerateInput{
		BindData:     data,
		Template:     RpcRegisterTemplate,
		TemplateName: "rpcRegisterTemplate",
		OutputPath:   filePath,
	}

	return
}

func WalkScanRpc(rpcDir string) ([]string, error) {
	RpcRegisterLogger.Trace("scan all rpc", "path", rpcDir)

	rpc := make([]string, 0)
	err := filepath.Walk(rpcDir, func(path string, info fs.FileInfo, err error) error {
		if strings.HasSuffix(path, ".go") {
			RpcRegisterLogger.Trace("collect rpc", "path", path)
			rs, e := getStructByBaseAndExcludeReturnType(path, "RpcBase", map[string]bool{"RpcReturnDataTypeTrigger": true})
			if e != nil {
				return e
			}

			rpc = append(rpc, rs...)

		}
		return nil
	})
	if err != nil {
		return nil, err
	}

	return rpc, nil
}

func getStructByBaseAndExcludeReturnType(filePath string, baseStructName string, returnTypes map[string]bool) (r []string, err error) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return r, err
	}

	mapRpc := map[string]struct {
		IsFoundBaseStruct bool
		IsExclude         bool
	}{}

	// Traverse the AST to find the struct with the Http attribute
	for _, decl := range file.Decls {

		ft, fok := decl.(*ast.FuncDecl)
		if fok {
			if ft.Name == nil || (ft.Name != nil && ft.Name.Name != "GetReturnType") {
				continue
			}

			startExp, isStartExp := ft.Recv.List[0].Type.(*ast.StarExpr)
			if !isStartExp {
				continue
			}
			stName := fmt.Sprintf("%s", startExp.X)

			// Iterate over the statements in the function body
			for _, stmt := range ft.Body.List {
				// Check if the statement is a return statement
				retStmt, isReturn := stmt.(*ast.ReturnStmt)
				if isReturn {
					// Iterate over the results in the return statement
					for _, result := range retStmt.Results {
						switch expr := result.(type) {
						case *ast.SelectorExpr:
							if returnTypes[expr.Sel.Name] {
								// isExclude = true
								if v, exist := mapRpc[stName]; exist {
									mapRpc[stName] = struct {
										IsFoundBaseStruct bool
										IsExclude         bool
									}{
										IsFoundBaseStruct: v.IsFoundBaseStruct,
										IsExclude:         true,
									}
								}
							}
						default:
							continue
						}
					}
				}
			}
			continue
		}

		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			st, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			if len(st.Fields.List) == 0 {
				continue
			}

			for _, f := range st.Fields.List {
				if se, isSe := f.Type.(*ast.SelectorExpr); isSe && se.Sel.Name == baseStructName {
					if _, exist := mapRpc[typeSpec.Name.Name]; !exist {
						mapRpc[typeSpec.Name.Name] = struct {
							IsFoundBaseStruct bool
							IsExclude         bool
						}{
							IsFoundBaseStruct: true,
							IsExclude:         false,
						}
					}
					continue
				}
			}

		}
	}

	for structName, checkValue := range mapRpc {
		if checkValue.IsFoundBaseStruct && checkValue.IsExclude {
			continue
		}
		r = append(r, structName)
	}

	return
}
